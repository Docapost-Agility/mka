{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///mka.min.js","webpack:///webpack/bootstrap c43bf005f273e98966c8","webpack:///./src/js/main.js","webpack:///./src/js/dbClick.js","webpack:///./src/js/rightClick.js","webpack:///./src/js/DragAndDrop.js","webpack:///./src/js/select.js","webpack:///./src/js/copyPaste.js","webpack:///./src/js/count.js","webpack:///./src/js/arrows.js","webpack:///./src/js/deleteShortcut.js","webpack:///./src/js/selectAllShortcut.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireWildcard","obj","newObj","key","default","_dbClick","dbClick","_rightClick","rightClick","_DragAndDrop","dndHandler","_select","select","_copyPaste","copyPaste","_count","count","_arrows","arrows","_deleteShortcut","deleteShortcut","_selectAllShortcut","selectAllShortcut","defaultConfigs","eltsSelectable","eltSelectedClass","eltSelectingClass","onDragItemClass","dragNdrop","droppableElements","lasso","pasteFunction","items","console","log","updateSelection","container","newSelection","actionId","configs","mkaParams","components","selectables","sameSelection","selection","length","forEach","elt","indexOf","classList","remove","add","params","parentFunctions","getPublicFunctions","component","onSelectionUpdate","getConfigs","clientConfigs","keys","pushComponents","push","customProperties","getContainer","setProperty","value","getProperty","elementIsSelected","contains","parentNode","getSelectableElement","getSelectablesElements","getLastSelectedInDom","last","offsetTop","offsetLeft","getSelection","copy","removeElements","elements","index","splice","removeChild","isMkaContainerFocused","target","initComponents","init","bindEvents","publicFunctions","bindComponentsEvents","eventName","saveIfAlreadyExists","event","stop","forceStop","mouseEventsList","mouseEventsTargets","window","document","body","keyEventsList","mouseEventTarget","mouseEventName","keyEventName","refreshComponents","refresh","updateSelectableElements","mkaSelectable","mkaRefresh","newSelectables","slice","querySelectorAll","listenContainerDOMChange","containsSelectableElement","node","selectablesNodes","item","MutationObserver","mutations","needToRefresh","mutation","addedNodes","removedNodes","observe","childList","subtree","addEventListener","setTimeout","HTMLElement","mkaInit","style","userSelect","getOffsetBody","offsetType","offset","offsetParent","offsetBodyLeft","offsetBodyTop","offsetBodyRight","offsetBodyBottom","mkaEvents","ondblclick","e","conf","element","removeMkaRcMenu","bindContextMenu","windowEvents","onkeydown","code","which","getElementById","preventDefault","onclick","menu","display","getMkaRcMenu","createElement","setAttribute","appendChild","selectableElement","htmlMenu","innerHTML","position","left","pageX","top","pageY","bindDragEvents","bindDropEvents","draggable","onmousedown","documentEvents","onmousemove","isDragging","onmouseup","innerCode","wrapper","wrapperSize","scrollWidth","id","width","setWrapperStyle","dataTransfer","setDragImage","setData","outerHTML","dropper","wrapperChildren","children","childDistance","opacity","child","color","backgroundColor","border","padding","textAlign","span","height","lineHeight","right","zIndex","borderRadius","refreshLasso","squareId","Math","floor","random","square","downX","downY","upX","upY","squareElt","y1","x1","x2","y2","isVisble","isCrossingElt","elementIsCrossingZone","shiftKey","selectableElements","focusedElementIndex","elementIndex","firstIndex","min","lastIndex","max","ctrlKey","eltIndex","orderCoordinate","endLasso","isInLasso","clearSelecting","selectableElt","lastSelection","selecting","pushSelectingElements","selectLassoItems","mkaElts","rect","getBoundingClientRect","zoneElt","onkeyup","calculateNextElement","lastSelected","centerScroll","scrollX","offsetWidth","innerWidth","scrollY","offsetHeight","innerHeight","scrollBy","nextElement","newElements","searchNextElement","concat","firstElement","fromElement","posX","posY","updateX","updateY","lineChanged","isSameLineThanOrigin","eltCenterY","getNextElement","isNewLine","elementFromPoint"],"mappings":"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","file":"mka.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"mka\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mka\"] = factory();\n\telse\n\t\troot[\"mka\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"mka\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mka\"] = factory();\n\telse\n\t\troot[\"mka\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _dbClick = __webpack_require__(1);\n\nvar dbClick = _interopRequireWildcard(_dbClick);\n\nvar _rightClick = __webpack_require__(2);\n\nvar rightClick = _interopRequireWildcard(_rightClick);\n\nvar _DragAndDrop = __webpack_require__(3);\n\nvar dndHandler = _interopRequireWildcard(_DragAndDrop);\n\nvar _select = __webpack_require__(4);\n\nvar select = _interopRequireWildcard(_select);\n\nvar _copyPaste = __webpack_require__(5);\n\nvar copyPaste = _interopRequireWildcard(_copyPaste);\n\nvar _count = __webpack_require__(6);\n\nvar count = _interopRequireWildcard(_count);\n\nvar _arrows = __webpack_require__(7);\n\nvar arrows = _interopRequireWildcard(_arrows);\n\nvar _deleteShortcut = __webpack_require__(8);\n\nvar deleteShortcut = _interopRequireWildcard(_deleteShortcut);\n\nvar _selectAllShortcut = __webpack_require__(9);\n\nvar selectAllShortcut = _interopRequireWildcard(_selectAllShortcut);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar defaultConfigs = {\n    \"eltsSelectable\": '',\n    \"eltSelectedClass\": \"mka-elt-selected\",\n    \"eltSelectingClass\": \"mka-elt-selecting\",\n    \"onDragItemClass\": null,\n    \"dragNdrop\": false,\n    \"droppableElements\": '',\n    \"rightClick\": false,\n    \"dbClick\": false,\n    \"lasso\": true,\n    \"selectAllShortcut\": true,\n    \"copyPaste\": true,\n    \"arrows\": true,\n    \"deleteShortcut\": false,\n    \"count\": \"\",\n    \"pasteFunction\": function pasteFunction(items) {\n        console.log(items);\n        console.log(\"Default past function, think to implement this function\");\n    }\n};\n\nvar _updateSelection = function _updateSelection(container, newSelection, actionId) {\n    var configs = container.mkaParams.configs;\n    var components = container.mkaParams.components;\n    var selectables = container.mkaParams.selectables;\n\n    var sameSelection = false;\n    if (container.mkaParams.selection.length === newSelection.length) {\n        sameSelection = true;\n        container.mkaParams.selection.forEach(function (elt) {\n            if (newSelection.indexOf(elt) === -1) {\n                sameSelection = false;\n            }\n        });\n    }\n    if (!sameSelection) {\n        container.mkaParams.selection = newSelection;\n        selectables.forEach(function (elt) {\n            elt.classList.remove(configs.eltSelectedClass);\n        });\n        container.mkaParams.selection.forEach(function (elt) {\n            elt.classList.add(configs.eltSelectedClass);\n        });\n        var params = {\n            selection: container.mkaParams.selection,\n            selectables: container.mkaParams.selectables,\n            configs: container.mkaParams.configs,\n            parentFunctions: getPublicFunctions(container),\n            actionId: actionId\n        };\n        components.forEach(function (component) {\n            component.onSelectionUpdate && component.onSelectionUpdate(params);\n        });\n    }\n};\n\nvar getConfigs = function getConfigs(clientConfigs) {\n    var configs = {};\n    Object.keys(defaultConfigs).forEach(function (i) {\n        configs[i] = typeof clientConfigs[i] !== 'undefined' ? clientConfigs[i] : defaultConfigs[i];\n    });\n    return configs;\n};\n\nvar pushComponents = function pushComponents(container) {\n    var configs = container.mkaParams.configs;\n\n    container.mkaParams.components = [];\n\n    if (!!configs.dbClick) {\n        container.mkaParams.components.push(dbClick);\n    }\n\n    if (!!configs.rightClick) {\n        container.mkaParams.components.push(rightClick);\n    }\n\n    if (configs.dragNdrop) {\n        container.mkaParams.components.push(dndHandler);\n    }\n\n    if (configs.selectAllShortcut) {\n        container.mkaParams.components.push(selectAllShortcut);\n    }\n\n    if (configs.copyPaste) {\n        container.mkaParams.components.push(copyPaste);\n    }\n\n    if (!!configs.deleteShortcut) {\n        container.mkaParams.components.push(deleteShortcut);\n    }\n\n    if (!!configs.arrows) {\n        container.mkaParams.components.push(arrows);\n    }\n    if (!!configs.count) {\n        container.mkaParams.components.push(count);\n    }\n\n    container.mkaParams.components.push(select);\n};\n\nvar getPublicFunctions = function getPublicFunctions(container) {\n    var configs = container.mkaParams.configs;\n    var components = container.mkaParams.components;\n\n    container.mkaParams.customProperties = container.mkaParams.customProperties || {};\n\n    return {\n        getContainer: function getContainer() {\n            return container;\n        },\n        setProperty: function setProperty(key, value) {\n            container.mkaParams.customProperties[key] = value;\n        },\n        getProperty: function getProperty(key) {\n            return container.mkaParams.customProperties[key];\n        },\n        elementIsSelected: function elementIsSelected(elt) {\n            if (elt.classList && elt.classList.contains(configs.eltSelectedClass)) {\n                return true;\n            }\n            while (elt.parentNode) {\n                elt = elt.parentNode;\n                if (elt.classList && elt.classList.contains(configs.eltSelectedClass)) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        getSelectableElement: function getSelectableElement(elt) {\n            var selectables = container.mkaParams.selectables;\n            if (elt.classList && selectables.indexOf(elt) !== -1) {\n                return elt;\n            }\n            while (elt.parentNode) {\n                elt = elt.parentNode;\n                if (elt.classList && selectables.indexOf(elt) !== -1) {\n                    return elt;\n                }\n            }\n            return null;\n        },\n        getSelectablesElements: function getSelectablesElements() {\n            return container.mkaParams.selectables;\n            ;\n        },\n        getLastSelectedInDom: function getLastSelectedInDom() {\n            var last = null;\n            container.mkaParams.selection.forEach(function (elt) {\n                if (!last || elt.offsetTop > last.offsetTop || elt.offsetTop === last.offsetTop && elt.offsetLeft > last.offsetLeft) {\n                    last = elt;\n                }\n            });\n            return last;\n        },\n        getSelection: function getSelection() {\n            var copy = [];\n            container.mkaParams.selection.forEach(function (elt) {\n                copy.push(elt);\n            });\n            return copy;\n        },\n        updateSelection: function updateSelection(newSelection, actionId) {\n            _updateSelection(container, newSelection, actionId);\n        },\n        removeElements: function removeElements(elements) {\n            elements.forEach(function (elt) {\n                var index = container.mkaParams.selectables.indexOf(elt);\n                if (index !== -1) {\n                    container.mkaParams.selectables.splice(index, 1);\n                }\n                index = container.mkaParams.selection.indexOf(elt);\n                if (index !== -1) {\n                    container.mkaParams.selection.splice(index, 1);\n                }\n                elt.parentNode.removeChild(elt);\n            });\n            components.forEach(function (component) {\n                component.onSelectionUpdate && component.onSelectionUpdate(container.mkaParams.selection, container.mkaParams.selectables);\n            });\n        },\n        isMkaContainerFocused: function isMkaContainerFocused(target) {\n            if (target === container) {\n                return true;\n            }\n\n            while (target.parentNode) {\n                target = target.parentNode;\n\n                if (target === container) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n};\n\nvar initComponents = function initComponents(container) {\n    var configs = container.mkaParams.configs;\n    var components = container.mkaParams.components;\n\n    components.forEach(function (component) {\n        component.init && component.init(configs, getPublicFunctions(container));\n    });\n};\n\nvar bindEvents = function bindEvents(container) {\n    var publicFunctions = getPublicFunctions(container);\n    var components = container.mkaParams.components;\n\n    var bindComponentsEvents = function bindComponentsEvents(target, eventName) {\n        var saveIfAlreadyExists = target.value[eventName];\n        target.value[eventName] = function (event) {\n            var stop = false;\n            if (saveIfAlreadyExists && typeof saveIfAlreadyExists === 'function') {\n                stop = saveIfAlreadyExists(event).forceStop;\n            }\n            components.forEach(function (component) {\n                if (!stop) {\n                    stop = component[target.name] && component[target.name][eventName] && component[target.name][eventName](event, publicFunctions, container.mkaParams.configs) || false;\n                }\n            });\n            return { forceStop: stop };\n        };\n    };\n\n    var mouseEventsList = [\"onmousedown\", \"onmousemove\", \"onmouseup\", \"onclick\", \"ondblclick\"];\n    var mouseEventsTargets = [{ name: \"windowEvents\", value: window }, { name: \"documentEvents\", value: document.body }, { name: \"mkaEvents\", value: container }];\n\n    var keyEventsList = [\"onkeydown\", \"onkeypress\", \"onkeyup\"];\n\n    mouseEventsTargets.forEach(function (mouseEventTarget) {\n        mouseEventsList.forEach(function (mouseEventName) {\n            bindComponentsEvents(mouseEventTarget, mouseEventName);\n        });\n    });\n\n    keyEventsList.forEach(function (keyEventName) {\n        bindComponentsEvents({ name: \"windowEvents\", value: window }, keyEventName);\n    });\n};\n\nvar refreshComponents = function refreshComponents(container) {\n    var components = container.mkaParams.components;\n\n    components.forEach(function (component) {\n        component.refresh && component.refresh(container.mkaParams.selectables, container.mkaParams.configs);\n    });\n};\n\nvar updateSelectableElements = function updateSelectableElements(container, elements) {\n    if (container.mkaParams.selectables) {\n        container.mkaParams.selectables.forEach(function (elt) {\n            elt.mkaSelectable = false;\n        });\n    }\n    elements.forEach(function (elt) {\n        elt.mkaSelectable = true;\n    });\n    container.mkaParams.selectables = elements;\n};\n\nvar mkaRefresh = function mkaRefresh(container) {\n    var newSelectables = [].slice.call(container.querySelectorAll(container.mkaParams.configs.eltsSelectable));\n    var newSelection = [];\n    container.mkaParams.selection.forEach(function (elt) {\n        if (newSelectables.indexOf(elt) !== -1) {\n            newSelection.push(elt);\n        }\n    });\n    _updateSelection(container, newSelection);\n\n    updateSelectableElements(container, newSelectables);\n\n    refreshComponents(container);\n};\n\nvar listenContainerDOMChange = function listenContainerDOMChange(container) {\n    var containsSelectableElement = function containsSelectableElement(node) {\n        //Check if removed node is selectable\n        if (!!node.mkaSelectable) {\n            return true;\n        }\n\n        //Check if added node is selectable\n        var parentNode = node.parentNode;\n        if (parentNode) {\n            var selectablesNodes = parentNode.querySelectorAll(container.mkaParams.configs.eltsSelectable);\n            for (var i = 0; i < selectablesNodes.length; i++) {\n                if (selectablesNodes.item(i) === node) {\n                    return true;\n                }\n            }\n        }\n\n        //Check if current node contains selectables elements\n        if (node.querySelectorAll && node.querySelectorAll(container.mkaParams.configs.eltsSelectable).length > 0) {\n            return true;\n        }\n\n        return false;\n    };\n\n    // Function to detect when dom change for refresh selectable elements\n    if (typeof MutationObserver !== \"undefined\") {\n        var observer = new MutationObserver(function (mutations) {\n            var needToRefresh = false;\n            mutations.forEach(function (mutation) {\n                if (!needToRefresh) {\n                    // If new element are added\n                    if (mutation.addedNodes) {\n                        for (var i = 0; i < mutation.addedNodes.length; i++) {\n                            needToRefresh = containsSelectableElement(mutation.addedNodes.item(i));\n                        }\n                    }\n                    // If element are removed\n                    if (mutation.removedNodes) {\n                        for (var _i = 0; _i < mutation.removedNodes.length; _i++) {\n                            needToRefresh = containsSelectableElement(mutation.removedNodes.item(_i));\n                        }\n                    }\n                }\n            });\n            if (needToRefresh) {\n                mkaRefresh(container);\n            }\n        });\n\n        observer.observe(container, { childList: true, subtree: true });\n    } else {\n        //IE < 11\n        container.addEventListener('DOMNodeRemoved', function (event) {\n            if (containsSelectableElement(event.target)) {\n                setTimeout(function () {\n                    mkaRefresh(container);\n                }, 0);\n            }\n        });\n        container.addEventListener('DOMNodeInserted', function (event) {\n            if (containsSelectableElement(event.target)) {\n                setTimeout(function () {\n                    mkaRefresh(container);\n                }, 0);\n            }\n        });\n    }\n};\n\nHTMLElement.prototype.mkaInit = function (clientConfigs) {\n    var container = this;\n    container.style.userSelect = \"none\";\n    container.style['-moz-user-select'] = 'none';\n    container.style['-webkit-user-select'] = 'none';\n    container.style['-ms-user-select'] = 'none';\n\n    var configs = getConfigs(clientConfigs);\n\n    var selectables = [].slice.call(container.querySelectorAll(configs.eltsSelectable));\n\n    container.mkaParams = {\n        configs: configs,\n        selection: []\n    };\n    updateSelectableElements(container, selectables);\n\n    pushComponents(container);\n\n    initComponents(container);\n\n    bindEvents(container);\n\n    listenContainerDOMChange(container);\n};\n\nHTMLElement.prototype.mkaRefresh = function () {\n    var container = this;\n\n    if (!container.mkaParams || !container.mkaParams.configs) {\n        console.log(\"No MKA found on this element, call mkaInit first\");\n        return false;\n    }\n\n    mkaRefresh(container);\n};\n\nvar getOffsetBody = function getOffsetBody(elt, offsetType) {\n    var offset = elt[offsetType];\n    while (elt.offsetParent !== document.body) {\n        elt = elt.offsetParent;\n        offset = offset + elt[offsetType];\n    }\n    return offset;\n};\n\nHTMLElement.prototype.offsetBodyLeft = function () {\n    return getOffsetBody(this, \"offsetLeft\");\n};\n\nHTMLElement.prototype.offsetBodyTop = function () {\n    return getOffsetBody(this, \"offsetTop\");\n};\n\nHTMLElement.prototype.offsetBodyRight = function () {\n    return getOffsetBody(this, \"offsetRight\");\n};\n\nHTMLElement.prototype.offsetBodyBottom = function () {\n    return getOffsetBody(this, \"offsetBottom\");\n};\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar mkaEvents = exports.mkaEvents = {\n    ondblclick: function ondblclick(e, parentFunctions, conf) {\n        var element = parentFunctions.getSelectableElement(e.target);\n        if (!!element && typeof conf.dbClick === 'function') {\n            parentFunctions.updateSelection([element]);\n            conf.dbClick(element);\n            return true;\n        }\n        return false;\n    }\n};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar mkarcmenuId = 'mkarcmenu';\n\nvar init = exports.init = function init(conf, parentFunctions) {\n    bindContextMenu(conf, parentFunctions);\n};\n\nvar windowEvents = exports.windowEvents = {\n    onkeydown: function onkeydown(event) {\n        var code = event.which;\n        if ((code == 37 || code == 38 || code == 39 || code == 40) && !!document.getElementById(mkarcmenuId)) {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    },\n    onclick: function onclick(event) {\n        if (event.which === 1) {\n            return removeMkaRcMenu();\n        }\n        return false;\n    }\n};\n\nvar removeMkaRcMenu = function removeMkaRcMenu() {\n    var menu = document.getElementById(mkarcmenuId);\n    if (menu && menu.style.display !== 'none') {\n        menu.style.display = 'none';\n        return true;\n    }\n    return false;\n};\n\nvar getMkaRcMenu = function getMkaRcMenu() {\n    var menu = document.getElementById(mkarcmenuId);\n    if (!menu) {\n        menu = document.createElement('div');\n        menu.setAttribute('id', mkarcmenuId);\n        document.body.appendChild(menu);\n    }\n    return menu;\n};\n\nvar bindContextMenu = function bindContextMenu(conf, parentFunctions) {\n\n    // On désactive le click droit sur l'élément principal\n    parentFunctions.getContainer().addEventListener('contextmenu', function (event) {\n        event.preventDefault();\n        removeMkaRcMenu();\n        var selectableElement = parentFunctions.getSelectableElement(event.target);\n\n        if (selectableElement !== null) {\n            // Si l'élément n'est pas sélectionné, on restreint la sélection à ce seul élémentœ\n            if (!parentFunctions.elementIsSelected(selectableElement)) {\n                parentFunctions.updateSelection([selectableElement]);\n            }\n        } else {\n            parentFunctions.updateSelection([]);\n        }\n\n        var selection = parentFunctions.getSelection();\n\n        var menu = getMkaRcMenu();\n        var htmlMenu = conf.rightClick(selection);\n\n        if (htmlMenu instanceof HTMLElement) {\n            menu.innerHTML = '';\n            menu.appendChild(htmlMenu);\n        } else {\n            menu.innerHTML = htmlMenu;\n        }\n\n        menu.style.position = 'absolute';\n        menu.style.left = event.pageX + 'px';\n        menu.style.top = event.pageY + 'px';\n        menu.style.display = 'block';\n    });\n};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar init = exports.init = function init(conf, parentFunctions) {\n    // config = conf;\n    parentFunctions.setProperty('isDragging', false);\n    parentFunctions.setProperty('draggableTarget', false);\n\n    var elements = parentFunctions.getSelectablesElements();\n\n    //Application du drag event pour chaque element ayant la classe mka-elt\n    elements.forEach(function (elt) {\n        bindDragEvents(elt, parentFunctions, conf);\n    });\n\n    if (conf.droppableElements) {\n        var droppers = [].slice.call(document.querySelectorAll(conf.droppableElements));\n        //Application du drop event pour chaque element ayant la classe mka-dropzone\n        droppers.forEach(function (elt) {\n            return bindDropEvents(elt, parentFunctions, conf);\n        });\n    }\n};\n\nvar onSelectionUpdate = exports.onSelectionUpdate = function onSelectionUpdate(params) {\n    params.selectables.forEach(function (elt) {\n        elt.draggable = false;\n    });\n    params.selection.forEach(function (elt) {\n        elt.draggable = true;\n    });\n};\n\nvar mkaEvents = exports.mkaEvents = {\n    onmousedown: function onmousedown(event, parentFunctions) {\n        parentFunctions.setProperty('draggableTarget', event.target && parentFunctions.elementIsSelected(event.target));\n        return false;\n    }\n};\n\nvar documentEvents = exports.documentEvents = {\n    onmousemove: function onmousemove(event, parentFunctions) {\n        var isDragging = parentFunctions.getProperty('draggableTarget');\n        parentFunctions.setProperty('isDragging', isDragging);\n        return isDragging;\n    }\n};\n\nvar windowEvents = exports.windowEvents = {\n    onmouseup: function onmouseup(event, parentFunctions) {\n        parentFunctions.setProperty('isDragging', false);\n        parentFunctions.setProperty('draggableTarget', false);\n        return false;\n    }\n};\n\nvar bindDragEvents = function bindDragEvents(element, parentFunctions, conf) {\n\n    element.addEventListener('dragstart', function (e) {\n        // On recupere les élts sélectionnés\n        var selection = parentFunctions.getSelection();\n\n        // on ajoute une class pour modifier le style de la selection\n        selection.forEach(function (elt) {\n            return elt.classList.add(\"on-drag\");\n        });\n\n        var innerCode = \"\";\n        var wrapper = document.createElement('div');\n        var wrapperSize = selection[0].scrollWidth;\n\n        //On rajoute le code html de chaque éléments dans une variable\n        //Chaque élément possède une div parente (Nécessaire lorsque le wrapper passe dans setWrapperStyle)\n        selection.forEach(function (elt) {\n            innerCode += '<div> ' + elt.innerHTML + ' </div>';\n        });\n\n        //On set le innerHTML avec tous les éléments récupérés précedemment\n        wrapper.innerHTML = innerCode;\n        wrapper.id = \"wrapper-drag\";\n        wrapper.style.width = wrapperSize + \"px\";\n\n        //On set la position sur absolute et on sort le wrapper de la page sinon ce dernier s'affiche lors du drag\n        wrapper.style.position = \"absolute\";\n        wrapper.style.top = \"-10000px\";\n\n        wrapper = setWrapperStyle(wrapper, conf);\n\n        document.body.appendChild(wrapper);\n\n        e.dataTransfer.setDragImage(wrapper, 0, 0);\n\n        e.dataTransfer.setData('text/plain', '');\n    });\n\n    element.addEventListener('dragend', function (e) {\n        var selection = parentFunctions.getSelection();\n        // On supprime la div avec l'id wrapper-drag\n        document.getElementById(\"wrapper-drag\").outerHTML = \"\";\n\n        // on retire la class\n        selection.forEach(function (elt) {\n            return elt.classList.remove(\"on-drag\");\n        });\n    });\n};\n\nvar bindDropEvents = function bindDropEvents(dropper, parentFunctions, conf) {\n\n    dropper.addEventListener('dragover', function (e) {\n        //Ajout de la classe pour le hover de la dropzone\n        // Cela permet de voir les zone qui peut recevoir la selection\n        this.classList.add('zone-hover');\n\n        // Il faut absolument laisser le preventDefault pour que le drop sur la zone s'execute\n        e.preventDefault();\n    });\n\n    dropper.addEventListener('dragleave', function () {\n        // On retire la class\n        this.classList.remove('zone-hover');\n    });\n\n    dropper.addEventListener('drop', function (e) {\n        // Lorsque l'utilisateur relache la sélection sur la zone dropable\n        // on execute l'action défini par l'utilsateur\n        var selection = parentFunctions.getSelection();\n        if (typeof conf.dragNdrop === 'function') {\n            conf.dragNdrop(selection, dropper);\n        }\n    });\n};\n\nvar setWrapperStyle = function setWrapperStyle(wrapper, conf) {\n    //On récupère les éléments enfants du wrapper qui servira pour le drag\n    var wrapperChildren = wrapper.children;\n    //On choisit le nombre de pixels qui séparera les éléments en fonction du nombre d'éléments dans la liste\n    var childDistance = wrapperChildren.length > 15 ? 1 : 2;\n\n    wrapper.style.opacity = \"1\";\n\n    // Pour chaque élément du wrapper\n    for (var i = 0; i < wrapperChildren.length; i++) {\n        var child = wrapperChildren[i];\n\n        //Si l'utilisateur a configuré le onDragItemsClass, on applique la classe en question\n        if (conf.onDragItemClass) {\n            child.classList.add(conf.onDragItemClass);\n        } else {\n            //Sinon on force un style par défaut si l'utilisateur n'a pas configuré le onDragItemsClass\n            child.style.color = \"black\";\n            child.style.backgroundColor = \"white\";\n            child.style.border = \"1px solid grey\";\n            child.style.padding = \"5px\";\n            child.style.textAlign = \"center\";\n            child.style.width = \"100%\";\n            // console.log(\"You can use your own class\");\n        }\n\n        // Chaque élément a une position abolute\n        // On multiplie i par un nombre de pixels pour indiquer le décalage et avoir un effet d'empilement\n        child.style.position = \"absolute\";\n        child.style.top = i * childDistance + \"px\";\n        child.style.left = i * childDistance + \"px\";\n\n        //Lorsqu'on parcourt le dernier élément et qu'il y a plus d'un élement\n        if (i === wrapperChildren.length - 1 && wrapperChildren.length > 1) {\n            //On crée une span qui contiendra le nombre d'élements selectionnés\n            var span = document.createElement(\"span\");\n            span.innerHTML = wrapperChildren.length;\n            span.style.height = \"25px\";\n            span.style.width = \"25px\";\n            span.style.lineHeight = \"25px\";\n            span.style.position = \"absolute\";\n            span.style.right = \"-10px\";\n            span.style.top = \"-5px\";\n            span.style.zIndex = \"25\";\n            span.style.borderRadius = \"15px\";\n            span.style.textAlign = \"center\";\n\n            //Si on n'a pas configuré le onDragItemClass alors on applique un style par défaut\n            if (!conf.onDragItemClass) {\n                span.style.backgroundColor = \"red\";\n                span.style.color = \"white\";\n            }\n            child.appendChild(span);\n        }\n    }\n\n    return wrapper;\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar init = exports.init = function init(conf, parentFunctions) {\n    parentFunctions.setProperty('focusedElementIndex', null);\n    parentFunctions.setProperty('selecting', []);\n\n    var squareId = \"selection-square-\" + Math.floor(Math.random() * 100000);\n\n    var square = {\n        downX: null,\n        downY: null,\n        upX: null,\n        upY: null,\n        get: function get() {\n            var squareElt = document.getElementById(squareId);\n            if (!squareElt) {\n                squareElt = document.createElement(\"div\");\n                squareElt.id = squareId;\n                squareElt.style.position = \"absolute\";\n                squareElt.style.backgroundColor = \"rgba(255,0,0,0.5)\";\n                squareElt.style.border = \"1px solid rgba(255,0,0,0.8)\";\n                squareElt.style.display = \"none\";\n                parentFunctions.getContainer().appendChild(squareElt);\n            }\n            return squareElt;\n        },\n        refresh: function refresh() {\n            var squareElt = square.get();\n            squareElt.style.display = \"block\";\n            squareElt.style.top = square.y1 + \"px\";\n            squareElt.style.left = square.x1 + \"px\";\n\n            squareElt.style.width = square.x2 - square.x1 + \"px\";\n            squareElt.style.height = square.y2 - square.y1 + \"px\";\n        },\n        remove: function remove() {\n            square.get().style.display = \"none\";\n        },\n        isVisble: function isVisble() {\n            return square.get().style.display === \"block\";\n        },\n        isCrossingElt: function isCrossingElt(elt) {\n            return elementIsCrossingZone(elt, square.x1, square.y1, square.x2, square.y2);\n        }\n    };\n    parentFunctions.setProperty('square', square);\n};\n\nvar mkaEvents = exports.mkaEvents = {\n    onmousedown: function onmousedown(event, parentFunctions) {\n        // On démarre la sélection si on utilise le bouton gauche de la souris\n        if (event.which === 1) {\n            if (!event.shiftKey) {\n                parentFunctions.setProperty('focusedElementIndex', null);\n\n                var square = parentFunctions.getProperty('square');\n                // zone du click\n                square.downX = event.pageX + 0;\n                square.downY = event.pageY + 0;\n                square.upX = event.pageX + 0;\n                square.upY = event.pageY + 0;\n                parentFunctions.setProperty('square', square);\n\n                parentFunctions.setProperty('canStartLasso', true);\n\n                orderCoordinate(square);\n            } else {\n                var selectableElements = parentFunctions.getSelectablesElements();\n                var selection = parentFunctions.getSelection();\n                var newSelection = [];\n\n                var element = parentFunctions.getSelectableElement(event.target);\n\n                if (element) {\n                    var focusedElementIndex = parentFunctions.getProperty('focusedElementIndex') || selectableElements.indexOf(selection[0]);\n                    parentFunctions.setProperty('focusedElementIndex', focusedElementIndex);\n\n                    if (selection.length > 0) {\n                        var elementIndex = selectableElements.indexOf(element);\n                        var firstIndex = Math.min(focusedElementIndex, elementIndex);\n                        var lastIndex = Math.max(focusedElementIndex, elementIndex);\n                        if (event.ctrlKey) {\n                            selection.forEach(function (elt) {\n                                var eltIndex = selectableElements.indexOf(elt);\n                                if (eltIndex < firstIndex) {\n                                    firstIndex = eltIndex;\n                                }\n                                if (eltIndex > lastIndex) {\n                                    lastIndex = eltIndex;\n                                }\n                            });\n                        }\n\n                        for (var i = firstIndex; i <= lastIndex; i++) {\n                            newSelection.push(selectableElements[i]);\n                        }\n                    } else {\n                        newSelection.push(element);\n                    }\n\n                    parentFunctions.updateSelection(newSelection);\n                }\n            }\n\n            return true;\n        }\n        return false;\n    },\n    ondblclick: function ondblclick(event, parentFunctions, conf) {\n        endLasso(parentFunctions, conf);\n        return false;\n    }\n};\n\nvar documentEvents = exports.documentEvents = {\n    onmousemove: function onmousemove(event, parentFunctions, conf) {\n        if (parentFunctions.getProperty('canStartLasso')) {\n            var isInLasso = conf.lasso && event.which === 1;\n            parentFunctions.setProperty('isInLasso', isInLasso);\n            if (isInLasso) {\n                if (!event.ctrlKey && !parentFunctions.getProperty('square').isVisble()) {\n                    parentFunctions.updateSelection([]);\n                    parentFunctions.setProperty('focusedElementIndex', null);\n                }\n                refreshLasso(event, parentFunctions, conf);\n                return true;\n            } else {\n                endLasso(parentFunctions, conf);\n            }\n        }\n        return false;\n    }\n};\n\nvar windowEvents = exports.windowEvents = {\n    onmousedown: function onmousedown(event, parentFunctions, conf) {\n        clearSelecting(parentFunctions, conf);\n        if (event.which === 1) {\n            if (!event.shiftKey) {\n                var selectableElt = parentFunctions.getSelectableElement(event.target);\n                if (selectableElt) {\n                    var lastSelection = parentFunctions.getSelection();\n                    var index = lastSelection.indexOf(selectableElt);\n                    var newSelection = [selectableElt];\n\n                    if (event.ctrlKey) {\n                        newSelection = lastSelection;\n                        if (index !== -1) {\n                            newSelection.splice(index, 1);\n                        } else {\n                            newSelection.push(selectableElt);\n                        }\n                    }\n\n                    var selecting = [];\n                    newSelection.forEach(function (elt) {\n                        selecting.push(elt);\n                        elt.classList.add(conf.eltSelectingClass);\n                    });\n                    parentFunctions.setProperty('selecting', selecting);\n                } else if (!event.ctrlKey) {\n                    parentFunctions.updateSelection([]);\n                }\n            }\n        }\n        return false;\n    },\n    onmouseup: function onmouseup(event, parentFunctions, conf) {\n        if (event.which === 1) {\n            pushSelectingElements(parentFunctions, conf);\n            endLasso(parentFunctions, conf);\n        }\n        return false;\n    }\n};\n\nvar refreshLasso = function refreshLasso(event, parentFunctions, conf) {\n    var square = parentFunctions.getProperty('square');\n    square.upX = event.pageX + 0;\n    square.upY = event.pageY + 0;\n    parentFunctions.setProperty('square', square);\n\n    orderCoordinate(square);\n\n    selectLassoItems(event.ctrlKey, square, parentFunctions, conf);\n    square.refresh();\n};\n\nvar endLasso = function endLasso(parentFunctions, conf) {\n    parentFunctions.getProperty('square').remove();\n    parentFunctions.setProperty('canStartLasso', false);\n\n    if (parentFunctions.getProperty('isInLasso')) {\n        parentFunctions.setProperty('isInLasso', false);\n        pushSelectingElements(parentFunctions, conf);\n    }\n};\n\nvar pushSelectingElements = function pushSelectingElements(parentFunctions, conf) {\n    if (parentFunctions.getProperty('selecting').length) {\n        parentFunctions.updateSelection(parentFunctions.getProperty('selecting'));\n        clearSelecting(parentFunctions, conf);\n    }\n};\n\nvar clearSelecting = function clearSelecting(parentFunctions, conf) {\n    parentFunctions.getProperty('selecting').forEach(function (elt) {\n        elt.classList.remove(conf.eltSelectingClass);\n    });\n    parentFunctions.setProperty('selecting', []);\n};\n\nvar orderCoordinate = function orderCoordinate(square) {\n    // we order coordinate to simplify\n    square.x1 = square.downX;\n    square.x2 = square.upX;\n    square.y1 = square.downY;\n    square.y2 = square.upY;\n    // on part vers la gauche\n    if (square.downX > square.upX) {\n        square.x1 = square.upX;\n        square.x2 = square.downX;\n    }\n\n    // on part vers le haut\n    if (square.downY > square.upY) {\n        square.y1 = square.upY;\n        square.y2 = square.downY;\n    }\n};\n\nvar selectLassoItems = function selectLassoItems(ctrlKey, square, parentFunctions, conf) {\n    var mkaElts = parentFunctions.getSelectablesElements();\n\n    var selecting = ctrlKey ? parentFunctions.getSelection() : [];\n\n    // on parcourt chaque elt pour savoir s'ils sont dans la zone selectionné\n    mkaElts.forEach(function (elt) {\n        elt.classList.remove(conf.eltSelectingClass);\n        if (square.isCrossingElt(elt) && (!ctrlKey || selecting.indexOf(elt) === -1)) {\n            selecting.push(elt);\n            elt.classList.add(conf.eltSelectingClass);\n        }\n    });\n    parentFunctions.setProperty('selecting', selecting);\n};\n\nvar elementIsCrossingZone = function elementIsCrossingZone(elt, x1, y1, x2, y2) {\n    var rect = elt.getBoundingClientRect();\n    var zoneElt = {\n        x1: elt.offsetBodyLeft(),\n        x2: elt.offsetBodyLeft() + rect.width,\n        y1: elt.offsetBodyTop(),\n        y2: elt.offsetBodyTop() + rect.height\n    };\n    return zoneElt.x2 > x1 && x2 > zoneElt.x1 && zoneElt.y2 > y1 && y2 > zoneElt.y1;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar init = exports.init = function init(conf, parentFunctions) {\n    parentFunctions.setProperty('copyElts', []);\n};\n\nvar windowEvents = exports.windowEvents = {\n    onkeyup: function onkeyup(e, parentFunctions, conf) {\n        if (e.which == '67' && e.ctrlKey) {\n            parentFunctions.setProperty('copyElts', parentFunctions.getSelection());\n        } else if (e.which == '86' && e.ctrlKey) {\n            conf.pasteFunction(parentFunctions.getProperty('copyElts'));\n        }\n    }\n};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar onSelectionUpdate = exports.onSelectionUpdate = function onSelectionUpdate(params) {\n    // si l'élément HTML mka-count existe\n    if (params.selection && params.configs && !!document.getElementById(params.configs.count)) {\n        document.getElementById(params.configs.count).innerHTML = params.selection.length;\n    }\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar init = exports.init = function init(conf, parentFunctions) {\n    parentFunctions.setProperty('arrows.currentFocus', null);\n    parentFunctions.setProperty('arrows.isContainerFocused', false);\n};\n\nvar onSelectionUpdate = exports.onSelectionUpdate = function onSelectionUpdate(params) {\n    var selection = params.selection;\n    var parentFunctions = params.parentFunctions;\n    if (selection && parentFunctions) {\n        if (selection.length > 0) {\n            parentFunctions.setProperty('arrows.lastSelected', selection[selection.length - 1]);\n            if (selection.length === 1) {\n                parentFunctions.setProperty('arrows.currentFocus', selection[0]);\n            } else if (params.actionId !== 'arrows.shift') {\n                parentFunctions.setProperty('arrows.currentFocus', null);\n            }\n        } else {\n            parentFunctions.setProperty('arrows.lastSelected', null);\n            parentFunctions.setProperty('arrows.currentFocus', null);\n        }\n    }\n};\n\nvar windowEvents = exports.windowEvents = {\n    onmousedown: function onmousedown(e, parentFunctions) {\n        parentFunctions.setProperty('arrows.isContainerFocused', parentFunctions.isMkaContainerFocused(e.target));\n        return false;\n    },\n    onkeydown: function onkeydown(event, parentFunctions) {\n        var code = event.which;\n        //37=left , 38=top , 39=right , 40=bottom\n        if (code == 37 || code == 38 || code == 39 || code == 40) {\n            var lastSelected = parentFunctions.getProperty('arrows.lastSelected');\n\n            if (!lastSelected) {\n                if (parentFunctions.getProperty('arrows.isContainerFocused')) {\n                    var firstElement = parentFunctions.getSelectablesElements()[0];\n                    if (firstElement) {\n                        parentFunctions.updateSelection([firstElement]);\n                    }\n                }\n            } else {\n                event.preventDefault();\n                var centerScroll = function centerScroll(elt) {\n                    var scrollX = elt.offsetBodyLeft() + elt.offsetWidth / 2 - (window.scrollX + window.innerWidth / 2);\n                    var scrollY = elt.offsetBodyTop() + elt.offsetHeight / 2 - (window.scrollY + window.innerHeight / 2);\n                    window.scrollBy(scrollX, scrollY);\n                };\n                centerScroll(lastSelected);\n\n                var nextElement = calculateNextElement(lastSelected, code, parentFunctions);\n\n                if (!!nextElement) {\n                    var newSelection = [];\n\n                    if (event.shiftKey && parentFunctions.getProperty('arrows.currentFocus')) {\n                        newSelection = parentFunctions.getSelection();\n                        var index = newSelection.indexOf(nextElement);\n                        if (code == 37 || code == 39) {\n                            if (index === -1) {\n                                newSelection.push(nextElement);\n                            } else {\n                                newSelection.splice(newSelection.length - 1, 1);\n                            }\n                        } else {\n                            var newElements = [];\n                            var searchNextElement = lastSelected;\n                            while (searchNextElement && searchNextElement !== nextElement) {\n                                searchNextElement = calculateNextElement(searchNextElement, code == 38 ? 37 : 39, parentFunctions);\n                                if (searchNextElement) {\n                                    newElements.push(searchNextElement);\n                                }\n                            }\n                            if (index === -1) {\n                                newSelection = newSelection.concat(newElements);\n                            } else {\n                                newSelection.splice(index + 1);\n                            }\n                        }\n                        parentFunctions.updateSelection(newSelection, 'arrows.shift');\n                    } else {\n                        newSelection = [nextElement];\n                        parentFunctions.updateSelection(newSelection);\n                    }\n\n                    centerScroll(nextElement);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\nvar calculateNextElement = function calculateNextElement(fromElement, code, parentFunctions) {\n    var interval = 10;\n    var rect = fromElement.getBoundingClientRect();\n    var posX = 0;\n    var posY = 0;\n    var updateX = 0;\n    var updateY = 0;\n    // let updateLine = 0;\n\n    switch (code) {\n        //left\n        case 37:\n            posX = fromElement.offsetBodyLeft();\n            posY = fromElement.offsetBodyTop() + rect.height / 2;\n            updateX = -interval;\n            break;\n        //up\n        case 38:\n            posX = fromElement.offsetBodyLeft() + rect.width / 2;\n            posY = fromElement.offsetBodyTop();\n            updateY = -interval;\n            break;\n        //right\n        case 39:\n            posX = fromElement.offsetBodyLeft() + rect.width;\n            posY = fromElement.offsetBodyTop() + rect.height / 2;\n            updateX = interval;\n            break;\n        //down\n        case 40:\n            posX = fromElement.offsetBodyLeft() + rect.width / 2;\n            posY = fromElement.offsetBodyTop() + rect.height;\n            updateY = interval;\n            break;\n    }\n\n    posX = posX + updateX;\n    posY = posY + updateY - window.scrollY;\n    var lineChanged = false;\n    var container = parentFunctions.getContainer();\n\n    var isSameLineThanOrigin = function isSameLineThanOrigin(elt) {\n        var eltCenterY = elt.offsetBodyTop() + elt.getBoundingClientRect().height / 2;\n        if (code === 37) {\n            return eltCenterY >= fromElement.offsetBodyTop();\n        } else if (code === 39) {\n            return eltCenterY <= fromElement.offsetBodyTop() + rect.height;\n        }\n    };\n\n    var getNextElement = function getNextElement(isNewLine) {\n        lineChanged = lineChanged || isNewLine;\n        var target = document.elementFromPoint(posX, posY);\n        var selectableElement = parentFunctions.getSelectableElement(target);\n        if (!selectableElement || lineChanged && isSameLineThanOrigin(selectableElement)) {\n            if (parentFunctions.isMkaContainerFocused(target)) {\n                posX = posX + updateX;\n                posY = posY + updateY;\n                return getNextElement();\n            } else {\n                if (code === 38 || code === 40 || isNewLine) {\n                    return null;\n                } else {\n                    if (code === 37) {\n                        posY = !lineChanged ? fromElement.offsetBodyTop() - interval - window.scrollY : posY - interval;\n                        posX = container.offsetBodyLeft() + container.getBoundingClientRect().width - interval;\n                    } else {\n                        posY = !lineChanged ? fromElement.offsetBodyTop() + rect.height + interval - window.scrollY : posY + interval;\n                        posX = container.offsetBodyLeft() + interval;\n                    }\n                    return getNextElement(true);\n                }\n            }\n        }\n        return selectableElement;\n    };\n    var nextElement = getNextElement();\n    return nextElement;\n};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar windowEvents = exports.windowEvents = {\n    onkeyup: function onkeyup(e, parentFunctions, conf) {\n\n        var selection = parentFunctions.getSelection();\n\n        if (e.which == '46' && selection.length > 0 && typeof conf.deleteShortcut === 'function') {\n            conf.deleteShortcut(selection);\n            return true;\n        }\n\n        return false;\n    }\n};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar init = exports.init = function init(conf, parentFunctions) {\n    parentFunctions.setProperty('isMkaContainerFocused', false);\n};\n\nvar windowEvents = exports.windowEvents = {\n    onkeydown: function onkeydown(e, parentFunctions) {\n        if (e.ctrlKey) {\n            var code = e.which;\n\n            if ((code === 65 || code === 97) && parentFunctions.getProperty('isMkaContainerFocused')) {\n                var newSelection = parentFunctions.getSelectablesElements();\n\n                parentFunctions.updateSelection(newSelection);\n\n                e.preventDefault();\n                return true;\n            }\n        }\n        return false;\n    },\n    onmousedown: function onmousedown(e, parentFunctions) {\n        parentFunctions.setProperty('isMkaContainerFocused', parentFunctions.isMkaContainerFocused(e.target));\n        return false;\n    }\n};\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// mka.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c43bf005f273e98966c8","import * as dbClick from './dbClick';\nimport * as rightClick from './rightClick';\nimport * as dndHandler from './DragAndDrop';\nimport * as select from './select';\nimport * as copyPaste from './copyPaste';\nimport * as count from './count';\nimport * as arrows from './arrows';\nimport * as deleteShortcut from './deleteShortcut';\nimport * as selectAllShortcut from './selectAllShortcut';\n\nlet defaultConfigs = {\n    \"eltsSelectable\": '',\n    \"eltSelectedClass\": \"mka-elt-selected\",\n    \"eltSelectingClass\": \"mka-elt-selecting\",\n    \"onDragItemClass\": null,\n    \"dragNdrop\": false,\n    \"droppableElements\": '',\n    \"rightClick\": false,\n    \"dbClick\": false,\n    \"lasso\": true,\n    \"selectAllShortcut\": true,\n    \"copyPaste\": true,\n    \"arrows\": true,\n    \"deleteShortcut\": false,\n    \"count\": \"\",\n    \"pasteFunction\": (items) => {\n        console.log(items);\n        console.log(\"Default past function, think to implement this function\");\n    }\n}\n\nlet updateSelection = (container, newSelection, actionId) => {\n    let configs = container.mkaParams.configs;\n    let components = container.mkaParams.components;\n    let selectables = container.mkaParams.selectables;\n\n    let sameSelection = false;\n    if (container.mkaParams.selection.length === newSelection.length) {\n        sameSelection = true;\n        container.mkaParams.selection.forEach(elt => {\n            if (newSelection.indexOf(elt) === -1) {\n                sameSelection = false;\n            }\n        });\n    }\n    if (!sameSelection) {\n        container.mkaParams.selection = newSelection;\n        selectables.forEach(elt => {\n            elt.classList.remove(configs.eltSelectedClass);\n        });\n        container.mkaParams.selection.forEach(elt => {\n            elt.classList.add(configs.eltSelectedClass);\n        });\n        let params = {\n            selection: container.mkaParams.selection,\n            selectables: container.mkaParams.selectables,\n            configs: container.mkaParams.configs,\n            parentFunctions: getPublicFunctions(container),\n            actionId: actionId\n        }\n        components.forEach(component => {\n            component.onSelectionUpdate && component.onSelectionUpdate(params);\n        });\n    }\n}\n\nlet getConfigs = (clientConfigs) => {\n    let configs = {};\n    Object.keys(defaultConfigs).forEach((i) => {\n        configs[i] = (typeof clientConfigs[i] !== 'undefined') ? clientConfigs[i] : defaultConfigs[i];\n    });\n    return configs;\n}\n\nlet pushComponents = (container) => {\n    let configs = container.mkaParams.configs;\n\n    container.mkaParams.components = [];\n\n    if (!!configs.dbClick) {\n        container.mkaParams.components.push(dbClick);\n    }\n\n    if (!!configs.rightClick) {\n        container.mkaParams.components.push(rightClick);\n    }\n\n    if (configs.dragNdrop) {\n        container.mkaParams.components.push(dndHandler);\n    }\n\n    if (configs.selectAllShortcut) {\n        container.mkaParams.components.push(selectAllShortcut);\n    }\n\n    if (configs.copyPaste) {\n        container.mkaParams.components.push(copyPaste);\n    }\n\n    if (!!configs.deleteShortcut) {\n        container.mkaParams.components.push(deleteShortcut);\n    }\n\n    if (!!configs.arrows) {\n        container.mkaParams.components.push(arrows);\n    }\n    if (!!configs.count) {\n        container.mkaParams.components.push(count);\n    }\n\n    container.mkaParams.components.push(select);\n}\n\nlet getPublicFunctions = (container) => {\n    let configs = container.mkaParams.configs;\n    let components = container.mkaParams.components;\n\n    container.mkaParams.customProperties = container.mkaParams.customProperties || {};\n\n    return {\n        getContainer: () => {\n            return container;\n        },\n        setProperty: (key, value) => {\n            container.mkaParams.customProperties[key] = value;\n        },\n        getProperty: (key) => {\n            return container.mkaParams.customProperties[key];\n        },\n        elementIsSelected: (elt) => {\n            if (elt.classList && elt.classList.contains(configs.eltSelectedClass)) {\n                return true;\n            }\n            while (elt.parentNode) {\n                elt = elt.parentNode;\n                if (elt.classList && elt.classList.contains(configs.eltSelectedClass)) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        getSelectableElement: (elt) => {\n            let selectables = container.mkaParams.selectables;\n            if (elt.classList && selectables.indexOf(elt) !== -1) {\n                return elt;\n            }\n            while (elt.parentNode) {\n                elt = elt.parentNode;\n                if (elt.classList && selectables.indexOf(elt) !== -1) {\n                    return elt;\n                }\n            }\n            return null;\n        },\n        getSelectablesElements: () => {\n            return container.mkaParams.selectables;\n            ;\n        },\n        getLastSelectedInDom: () => {\n            let last = null;\n            container.mkaParams.selection.forEach(elt => {\n                if (!last || elt.offsetTop > last.offsetTop || elt.offsetTop === last.offsetTop && elt.offsetLeft > last.offsetLeft) {\n                    last = elt;\n                }\n            });\n            return last;\n        },\n        getSelection: () => {\n            let copy = [];\n            container.mkaParams.selection.forEach(elt => {\n                copy.push(elt);\n            });\n            return copy;\n        },\n        updateSelection: (newSelection, actionId) => {\n            updateSelection(container, newSelection, actionId);\n        },\n        removeElements: (elements) => {\n            elements.forEach(elt => {\n                let index = container.mkaParams.selectables.indexOf(elt);\n                if (index !== -1) {\n                    container.mkaParams.selectables.splice(index, 1);\n                }\n                index = container.mkaParams.selection.indexOf(elt);\n                if (index !== -1) {\n                    container.mkaParams.selection.splice(index, 1);\n                }\n                elt.parentNode.removeChild(elt);\n            });\n            components.forEach(component => {\n                component.onSelectionUpdate && component.onSelectionUpdate(container.mkaParams.selection, container.mkaParams.selectables);\n            });\n        },\n        isMkaContainerFocused: (target) => {\n            if (target === container) {\n                return true;\n            }\n\n            while (target.parentNode) {\n                target = target.parentNode;\n\n                if (target === container) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }\n}\n\nlet initComponents = (container) => {\n    let configs = container.mkaParams.configs;\n    let components = container.mkaParams.components;\n\n    components.forEach(component => {\n        component.init && component.init(configs, getPublicFunctions(container));\n    });\n}\n\nlet bindEvents = (container) => {\n    let publicFunctions = getPublicFunctions(container);\n    let components = container.mkaParams.components;\n\n    let bindComponentsEvents = (target, eventName) => {\n        let saveIfAlreadyExists = target.value[eventName];\n        target.value[eventName] = (event) => {\n            let stop = false;\n            if (saveIfAlreadyExists && typeof saveIfAlreadyExists === 'function') {\n                stop = saveIfAlreadyExists(event).forceStop;\n            }\n            components.forEach(component => {\n                if (!stop) {\n                    stop = component[target.name] && component[target.name][eventName] && component[target.name][eventName](event, publicFunctions, container.mkaParams.configs) || false;\n                }\n            });\n            return {forceStop: stop};\n        }\n    }\n\n    let mouseEventsList = [\"onmousedown\", \"onmousemove\", \"onmouseup\", \"onclick\", \"ondblclick\"];\n    let mouseEventsTargets = [\n        {name: \"windowEvents\", value: window},\n        {name: \"documentEvents\", value: document.body},\n        {name: \"mkaEvents\", value: container}\n    ];\n\n    let keyEventsList = [\"onkeydown\", \"onkeypress\", \"onkeyup\"];\n\n    mouseEventsTargets.forEach(mouseEventTarget => {\n        mouseEventsList.forEach(mouseEventName => {\n            bindComponentsEvents(mouseEventTarget, mouseEventName);\n        });\n    });\n\n    keyEventsList.forEach(keyEventName => {\n        bindComponentsEvents({name: \"windowEvents\", value: window}, keyEventName);\n    });\n}\n\nlet refreshComponents = (container) => {\n    let components = container.mkaParams.components;\n\n    components.forEach(component => {\n        component.refresh && component.refresh(container.mkaParams.selectables, container.mkaParams.configs);\n    });\n}\n\nlet updateSelectableElements = (container, elements) => {\n    if (container.mkaParams.selectables) {\n        container.mkaParams.selectables.forEach(elt => {\n            elt.mkaSelectable = false;\n        });\n    }\n    elements.forEach(elt => {\n        elt.mkaSelectable = true;\n    });\n    container.mkaParams.selectables = elements;\n}\n\nlet mkaRefresh = (container) => {\n    let newSelectables = [].slice.call(container.querySelectorAll(container.mkaParams.configs.eltsSelectable));\n    let newSelection = [];\n    container.mkaParams.selection.forEach(elt => {\n        if (newSelectables.indexOf(elt) !== -1) {\n            newSelection.push(elt);\n        }\n    });\n    updateSelection(container, newSelection);\n\n    updateSelectableElements(container, newSelectables);\n\n    refreshComponents(container);\n}\n\nlet listenContainerDOMChange = (container) => {\n    let containsSelectableElement = (node) => {\n        //Check if removed node is selectable\n        if (!!node.mkaSelectable) {\n            return true;\n        }\n\n        //Check if added node is selectable\n        let parentNode = node.parentNode;\n        if (parentNode) {\n            let selectablesNodes = parentNode.querySelectorAll(container.mkaParams.configs.eltsSelectable);\n            for (let i = 0; i < selectablesNodes.length; i++) {\n                if (selectablesNodes.item(i) === node) {\n                    return true;\n                }\n            }\n        }\n\n        //Check if current node contains selectables elements\n        if (node.querySelectorAll && node.querySelectorAll(container.mkaParams.configs.eltsSelectable).length > 0) {\n            return true;\n        }\n\n        return false;\n\n    }\n\n    // Function to detect when dom change for refresh selectable elements\n    if (typeof MutationObserver !== \"undefined\") {\n        var observer = new MutationObserver(function (mutations) {\n            let needToRefresh = false;\n            mutations.forEach(function (mutation) {\n                if (!needToRefresh) {\n                    // If new element are added\n                    if (mutation.addedNodes) {\n                        for (let i = 0; i < mutation.addedNodes.length; i++) {\n                            needToRefresh = containsSelectableElement(mutation.addedNodes.item(i));\n                        }\n                    }\n                    // If element are removed\n                    if (mutation.removedNodes) {\n                        for (let i = 0; i < mutation.removedNodes.length; i++) {\n                            needToRefresh = containsSelectableElement(mutation.removedNodes.item(i));\n                        }\n                    }\n                }\n            });\n            if (needToRefresh) {\n                mkaRefresh(container);\n            }\n        });\n\n        observer.observe(container, {childList: true, subtree: true});\n    } else {\n        //IE < 11\n        container.addEventListener('DOMNodeRemoved', function (event) {\n            if (containsSelectableElement(event.target)) {\n                setTimeout(() => {\n                    mkaRefresh(container);\n                }, 0);\n            }\n        });\n        container.addEventListener('DOMNodeInserted', function (event) {\n            if (containsSelectableElement(event.target)) {\n                setTimeout(() => {\n                    mkaRefresh(container);\n                }, 0);\n            }\n        });\n    }\n}\n\nHTMLElement.prototype.mkaInit = function (clientConfigs) {\n    let container = this;\n    container.style.userSelect = \"none\";\n    container.style['-moz-user-select'] = 'none';\n    container.style['-webkit-user-select'] = 'none';\n    container.style['-ms-user-select'] = 'none';\n\n    let configs = getConfigs(clientConfigs);\n\n    let selectables = [].slice.call(container.querySelectorAll(configs.eltsSelectable));\n\n    container.mkaParams = {\n        configs: configs,\n        selection: []\n    };\n    updateSelectableElements(container, selectables);\n\n    pushComponents(container);\n\n    initComponents(container);\n\n    bindEvents(container);\n\n    listenContainerDOMChange(container);\n\n};\n\nHTMLElement.prototype.mkaRefresh = function () {\n    let container = this;\n\n    if (!container.mkaParams || !container.mkaParams.configs) {\n        console.log(\"No MKA found on this element, call mkaInit first\");\n        return false;\n    }\n\n    mkaRefresh(container);\n\n}\n\nlet getOffsetBody = (elt, offsetType) => {\n    let offset = elt[offsetType];\n    while (elt.offsetParent !== document.body) {\n        elt = elt.offsetParent;\n        offset = offset + elt[offsetType];\n    }\n    return offset;\n}\n\nHTMLElement.prototype.offsetBodyLeft = function () {\n    return getOffsetBody(this, \"offsetLeft\");\n}\n\nHTMLElement.prototype.offsetBodyTop = function () {\n    return getOffsetBody(this, \"offsetTop\");\n}\n\nHTMLElement.prototype.offsetBodyRight = function () {\n    return getOffsetBody(this, \"offsetRight\");\n}\n\nHTMLElement.prototype.offsetBodyBottom = function () {\n    return getOffsetBody(this, \"offsetBottom\");\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/main.js","export let mkaEvents = {\n    ondblclick: (e, parentFunctions, conf) => {\n        let element = parentFunctions.getSelectableElement(e.target);\n        if (!!element && typeof conf.dbClick === 'function') {\n            parentFunctions.updateSelection([element]);\n            conf.dbClick(element);\n            return true;\n        }\n        return false;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/dbClick.js","const mkarcmenuId = 'mkarcmenu';\n\nexport let init = (conf, parentFunctions) => {\n    bindContextMenu(conf, parentFunctions);\n}\n\nexport let windowEvents = {\n    onkeydown: (event) => {\n        let code = event.which;\n        if ((code == 37 || code == 38 || code == 39 || code == 40) && !!document.getElementById(mkarcmenuId)) {\n            event.preventDefault();\n            return true;\n        }\n        return false;\n    },\n    onclick: (event) => {\n        if (event.which === 1) {\n            return removeMkaRcMenu();\n        }\n        return false;\n    }\n}\n\nlet removeMkaRcMenu = () => {\n    const menu = document.getElementById(mkarcmenuId);\n    if (menu && menu.style.display !== 'none') {\n        menu.style.display = 'none';\n        return true;\n    }\n    return false;\n}\n\nlet getMkaRcMenu = () => {\n    let menu = document.getElementById(mkarcmenuId);\n    if (!menu) {\n        menu = document.createElement('div');\n        menu.setAttribute('id', mkarcmenuId);\n        document.body.appendChild(menu);\n    }\n    return menu;\n}\n\nlet bindContextMenu = (conf, parentFunctions) => {\n\n    // On désactive le click droit sur l'élément principal\n    parentFunctions.getContainer().addEventListener('contextmenu', (event) => {\n        event.preventDefault();\n        removeMkaRcMenu();\n        const selectableElement = parentFunctions.getSelectableElement(event.target);\n\n        if (selectableElement !== null) {\n            // Si l'élément n'est pas sélectionné, on restreint la sélection à ce seul élémentœ\n            if (!parentFunctions.elementIsSelected(selectableElement)) {\n                parentFunctions.updateSelection([selectableElement]);\n            }\n\n        } else {\n            parentFunctions.updateSelection([]);\n        }\n\n        let selection = parentFunctions.getSelection();\n\n        let menu = getMkaRcMenu();\n        let htmlMenu = conf.rightClick(selection);\n\n        if (htmlMenu instanceof HTMLElement) {\n            menu.innerHTML = '';\n            menu.appendChild(htmlMenu);\n        } else {\n            menu.innerHTML = htmlMenu;\n        }\n\n        menu.style.position = 'absolute';\n        menu.style.left = event.pageX + 'px';\n        menu.style.top = event.pageY + 'px';\n        menu.style.display = 'block';\n    });\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/rightClick.js","export let init = (conf, parentFunctions) => {\n    // config = conf;\n    parentFunctions.setProperty('isDragging', false);\n    parentFunctions.setProperty('draggableTarget', false);\n\n    let elements = parentFunctions.getSelectablesElements();\n\n    //Application du drag event pour chaque element ayant la classe mka-elt\n    elements.forEach(elt => {\n        bindDragEvents(elt, parentFunctions, conf);\n    });\n\n    if (conf.droppableElements) {\n        let droppers = [].slice.call(document.querySelectorAll(conf.droppableElements));\n        //Application du drop event pour chaque element ayant la classe mka-dropzone\n        droppers.forEach(elt => bindDropEvents(elt, parentFunctions, conf));\n    }\n}\n\nexport let onSelectionUpdate = (params) => {\n    params.selectables.forEach(elt => {\n        elt.draggable = false;\n    });\n    params.selection.forEach(elt => {\n        elt.draggable = true;\n    });\n};\n\nexport let mkaEvents = {\n    onmousedown: (event, parentFunctions) => {\n        parentFunctions.setProperty('draggableTarget', event.target && parentFunctions.elementIsSelected(event.target));\n        return false;\n    }\n};\n\nexport let documentEvents = {\n    onmousemove: (event, parentFunctions) => {\n        let isDragging = parentFunctions.getProperty('draggableTarget');\n        parentFunctions.setProperty('isDragging', isDragging);\n        return isDragging;\n    }\n};\n\nexport let windowEvents = {\n    onmouseup: (event, parentFunctions) => {\n        parentFunctions.setProperty('isDragging', false);\n        parentFunctions.setProperty('draggableTarget', false);\n        return false;\n    }\n};\n\nlet bindDragEvents = (element, parentFunctions, conf) => {\n\n    element.addEventListener('dragstart', function (e) {\n        // On recupere les élts sélectionnés\n        let selection = parentFunctions.getSelection();\n\n        // on ajoute une class pour modifier le style de la selection\n        selection.forEach((elt) => elt.classList.add(\"on-drag\"));\n\n        let innerCode = \"\";\n        let wrapper = document.createElement('div');\n        const wrapperSize = selection[0].scrollWidth;\n\n        //On rajoute le code html de chaque éléments dans une variable\n        //Chaque élément possède une div parente (Nécessaire lorsque le wrapper passe dans setWrapperStyle)\n        selection.forEach((elt) => {\n            innerCode += `<div> ${elt.innerHTML} </div>`;\n        });\n\n        //On set le innerHTML avec tous les éléments récupérés précedemment\n        wrapper.innerHTML = innerCode;\n        wrapper.id = \"wrapper-drag\";\n        wrapper.style.width = wrapperSize + \"px\";\n\n        //On set la position sur absolute et on sort le wrapper de la page sinon ce dernier s'affiche lors du drag\n        wrapper.style.position = \"absolute\";\n        wrapper.style.top = \"-10000px\";\n\n        wrapper = setWrapperStyle(wrapper, conf);\n\n        document.body.appendChild(wrapper);\n\n        e.dataTransfer.setDragImage(wrapper, 0, 0);\n\n        e.dataTransfer.setData('text/plain', '');\n\n    });\n\n    element.addEventListener('dragend', function (e) {\n        let selection = parentFunctions.getSelection();\n        // On supprime la div avec l'id wrapper-drag\n        document.getElementById(\"wrapper-drag\").outerHTML = \"\";\n\n        // on retire la class\n        selection.forEach((elt) => elt.classList.remove(\"on-drag\"));\n    });\n}\n\nlet bindDropEvents = (dropper, parentFunctions, conf) => {\n\n    dropper.addEventListener('dragover', function (e) {\n        //Ajout de la classe pour le hover de la dropzone\n        // Cela permet de voir les zone qui peut recevoir la selection\n        this.classList.add('zone-hover');\n\n        // Il faut absolument laisser le preventDefault pour que le drop sur la zone s'execute\n        e.preventDefault();\n    });\n\n    dropper.addEventListener('dragleave', function () {\n        // On retire la class\n        this.classList.remove('zone-hover');\n    });\n\n    dropper.addEventListener('drop', function (e) {\n        // Lorsque l'utilisateur relache la sélection sur la zone dropable\n        // on execute l'action défini par l'utilsateur\n        let selection = parentFunctions.getSelection();\n        if (typeof conf.dragNdrop === 'function') {\n            conf.dragNdrop(selection, dropper);\n        }\n    });\n}\n\n\nlet setWrapperStyle = (wrapper, conf) => {\n    //On récupère les éléments enfants du wrapper qui servira pour le drag\n    let wrapperChildren = wrapper.children;\n    //On choisit le nombre de pixels qui séparera les éléments en fonction du nombre d'éléments dans la liste\n    let childDistance = wrapperChildren.length > 15 ? 1 : 2;\n\n    wrapper.style.opacity = \"1\";\n\n    // Pour chaque élément du wrapper\n    for (let i = 0; i < wrapperChildren.length; i++) {\n        let child = wrapperChildren[i];\n\n        //Si l'utilisateur a configuré le onDragItemsClass, on applique la classe en question\n        if (conf.onDragItemClass) {\n            child.classList.add(conf.onDragItemClass);\n        } else {\n            //Sinon on force un style par défaut si l'utilisateur n'a pas configuré le onDragItemsClass\n            child.style.color = \"black\";\n            child.style.backgroundColor = \"white\";\n            child.style.border = \"1px solid grey\";\n            child.style.padding = \"5px\";\n            child.style.textAlign = \"center\";\n            child.style.width = \"100%\";\n            // console.log(\"You can use your own class\");\n        }\n\n        // Chaque élément a une position abolute\n        // On multiplie i par un nombre de pixels pour indiquer le décalage et avoir un effet d'empilement\n        child.style.position = \"absolute\";\n        child.style.top = (i * childDistance) + \"px\";\n        child.style.left = (i * childDistance) + \"px\";\n\n        //Lorsqu'on parcourt le dernier élément et qu'il y a plus d'un élement\n        if (i === wrapperChildren.length - 1 && wrapperChildren.length > 1) {\n            //On crée une span qui contiendra le nombre d'élements selectionnés\n            let span = document.createElement(\"span\");\n            span.innerHTML = wrapperChildren.length;\n            span.style.height = \"25px\";\n            span.style.width = \"25px\";\n            span.style.lineHeight = \"25px\";\n            span.style.position = \"absolute\";\n            span.style.right = \"-10px\";\n            span.style.top = \"-5px\";\n            span.style.zIndex = \"25\";\n            span.style.borderRadius = \"15px\";\n            span.style.textAlign = \"center\";\n\n            //Si on n'a pas configuré le onDragItemClass alors on applique un style par défaut\n            if (!conf.onDragItemClass) {\n                span.style.backgroundColor = \"red\";\n                span.style.color = \"white\";\n            }\n            child.appendChild(span);\n        }\n    }\n\n    return wrapper;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/DragAndDrop.js","export let init = (conf, parentFunctions) => {\n    parentFunctions.setProperty('focusedElementIndex', null);\n    parentFunctions.setProperty('selecting', []);\n\n    let squareId = \"selection-square-\" + Math.floor(Math.random() * 100000);\n\n    let square = {\n        downX: null,\n        downY: null,\n        upX: null,\n        upY: null,\n        get: () => {\n            let squareElt = document.getElementById(squareId);\n            if (!squareElt) {\n                squareElt = document.createElement(\"div\");\n                squareElt.id = squareId;\n                squareElt.style.position = \"absolute\";\n                squareElt.style.backgroundColor = \"rgba(255,0,0,0.5)\";\n                squareElt.style.border = \"1px solid rgba(255,0,0,0.8)\";\n                squareElt.style.display = \"none\";\n                parentFunctions.getContainer().appendChild(squareElt);\n            }\n            return squareElt;\n        },\n        refresh: () => {\n            let squareElt = square.get();\n            squareElt.style.display = \"block\";\n            squareElt.style.top = square.y1 + \"px\";\n            squareElt.style.left = square.x1 + \"px\";\n\n            squareElt.style.width = (square.x2 - square.x1) + \"px\";\n            squareElt.style.height = (square.y2 - square.y1) + \"px\";\n        },\n        remove: () => {\n            square.get().style.display = \"none\";\n        },\n        isVisble: () => {\n            return square.get().style.display === \"block\";\n        },\n        isCrossingElt: (elt) => {\n            return elementIsCrossingZone(elt, square.x1, square.y1, square.x2, square.y2);\n        }\n    };\n    parentFunctions.setProperty('square', square);\n}\n\nexport let mkaEvents = {\n    onmousedown: (event, parentFunctions) => {\n        // On démarre la sélection si on utilise le bouton gauche de la souris\n        if (event.which === 1) {\n            if (!event.shiftKey) {\n                parentFunctions.setProperty('focusedElementIndex', null);\n\n                let square = parentFunctions.getProperty('square');\n                // zone du click\n                square.downX = event.pageX + 0;\n                square.downY = event.pageY + 0;\n                square.upX = event.pageX + 0;\n                square.upY = event.pageY + 0;\n                parentFunctions.setProperty('square', square);\n\n                parentFunctions.setProperty('canStartLasso', true);\n\n                orderCoordinate(square);\n            } else {\n                let selectableElements = parentFunctions.getSelectablesElements();\n                let selection = parentFunctions.getSelection();\n                let newSelection = [];\n\n                let element = parentFunctions.getSelectableElement(event.target);\n\n                if (element) {\n                    let focusedElementIndex = parentFunctions.getProperty('focusedElementIndex') || selectableElements.indexOf(selection[0]);\n                    parentFunctions.setProperty('focusedElementIndex', focusedElementIndex);\n\n                    if (selection.length > 0) {\n                        let elementIndex = selectableElements.indexOf(element);\n                        let firstIndex = Math.min(focusedElementIndex, elementIndex);\n                        let lastIndex = Math.max(focusedElementIndex, elementIndex);\n                        if (event.ctrlKey) {\n                            selection.forEach(elt => {\n                                let eltIndex = selectableElements.indexOf(elt);\n                                if (eltIndex < firstIndex) {\n                                    firstIndex = eltIndex;\n                                }\n                                if (eltIndex > lastIndex) {\n                                    lastIndex = eltIndex;\n                                }\n                            });\n                        }\n\n                        for (let i = firstIndex; i <= lastIndex; i++) {\n                            newSelection.push(selectableElements[i]);\n                        }\n                    } else {\n                        newSelection.push(element);\n                    }\n\n                    parentFunctions.updateSelection(newSelection);\n                }\n            }\n\n            return true;\n        }\n        return false;\n    },\n    ondblclick: (event, parentFunctions, conf) => {\n        endLasso(parentFunctions, conf);\n        return false;\n    }\n};\n\nexport let documentEvents = {\n    onmousemove: (event, parentFunctions, conf) => {\n        if (parentFunctions.getProperty('canStartLasso')) {\n            let isInLasso = conf.lasso && event.which === 1;\n            parentFunctions.setProperty('isInLasso', isInLasso);\n            if (isInLasso) {\n                if (!event.ctrlKey && !parentFunctions.getProperty('square').isVisble()) {\n                    parentFunctions.updateSelection([]);\n                    parentFunctions.setProperty('focusedElementIndex', null);\n                }\n                refreshLasso(event, parentFunctions, conf);\n                return true;\n            } else {\n                endLasso(parentFunctions, conf);\n            }\n        }\n        return false;\n    }\n};\n\nexport let windowEvents = {\n    onmousedown: (event, parentFunctions, conf) => {\n        clearSelecting(parentFunctions, conf);\n        if (event.which === 1) {\n            if (!event.shiftKey) {\n                let selectableElt = parentFunctions.getSelectableElement(event.target);\n                if (selectableElt) {\n                    let lastSelection = parentFunctions.getSelection();\n                    let index = lastSelection.indexOf(selectableElt);\n                    let newSelection = [selectableElt];\n\n                    if (event.ctrlKey) {\n                        newSelection = lastSelection;\n                        if (index !== -1) {\n                            newSelection.splice(index, 1);\n                        } else {\n                            newSelection.push(selectableElt);\n                        }\n                    }\n\n                    let selecting = [];\n                    newSelection.forEach(elt => {\n                        selecting.push(elt);\n                        elt.classList.add(conf.eltSelectingClass);\n                    });\n                    parentFunctions.setProperty('selecting', selecting);\n\n                } else if (!event.ctrlKey) {\n                    parentFunctions.updateSelection([]);\n                }\n            }\n        }\n        return false;\n    },\n    onmouseup: (event, parentFunctions, conf) => {\n        if (event.which === 1) {\n            pushSelectingElements(parentFunctions, conf);\n            endLasso(parentFunctions, conf);\n        }\n        return false;\n    }\n};\n\nlet refreshLasso = (event, parentFunctions, conf) => {\n    let square = parentFunctions.getProperty('square');\n    square.upX = event.pageX + 0;\n    square.upY = event.pageY + 0;\n    parentFunctions.setProperty('square', square);\n\n    orderCoordinate(square);\n\n    selectLassoItems(event.ctrlKey, square, parentFunctions, conf);\n    square.refresh();\n\n};\n\nlet endLasso = (parentFunctions, conf) => {\n    parentFunctions.getProperty('square').remove();\n    parentFunctions.setProperty('canStartLasso', false);\n\n    if (parentFunctions.getProperty('isInLasso')) {\n        parentFunctions.setProperty('isInLasso', false);\n        pushSelectingElements(parentFunctions, conf);\n    }\n}\n\nlet pushSelectingElements = (parentFunctions, conf) => {\n    if (parentFunctions.getProperty('selecting').length) {\n        parentFunctions.updateSelection(parentFunctions.getProperty('selecting'));\n        clearSelecting(parentFunctions, conf);\n    }\n}\n\nlet clearSelecting = (parentFunctions, conf) => {\n    parentFunctions.getProperty('selecting').forEach(elt => {\n        elt.classList.remove(conf.eltSelectingClass);\n    });\n    parentFunctions.setProperty('selecting', []);\n}\n\nlet orderCoordinate = (square) => {\n    // we order coordinate to simplify\n    square.x1 = square.downX;\n    square.x2 = square.upX;\n    square.y1 = square.downY;\n    square.y2 = square.upY;\n    // on part vers la gauche\n    if (square.downX > square.upX) {\n        square.x1 = square.upX;\n        square.x2 = square.downX;\n    }\n\n    // on part vers le haut\n    if (square.downY > square.upY) {\n        square.y1 = square.upY;\n        square.y2 = square.downY;\n    }\n}\n\nlet selectLassoItems = (ctrlKey, square, parentFunctions, conf) => {\n    let mkaElts = parentFunctions.getSelectablesElements();\n\n    let selecting = (ctrlKey) ? parentFunctions.getSelection() : [];\n\n    // on parcourt chaque elt pour savoir s'ils sont dans la zone selectionné\n    mkaElts.forEach(elt => {\n        elt.classList.remove(conf.eltSelectingClass);\n        if (square.isCrossingElt(elt) && (!ctrlKey || selecting.indexOf(elt) === -1)) {\n            selecting.push(elt);\n            elt.classList.add(conf.eltSelectingClass);\n        }\n    });\n    parentFunctions.setProperty('selecting', selecting);\n}\n\nlet elementIsCrossingZone = (elt, x1, y1, x2, y2) => {\n    let rect = elt.getBoundingClientRect();\n    let zoneElt = {\n        x1: elt.offsetBodyLeft(),\n        x2: (elt.offsetBodyLeft() + rect.width),\n        y1: elt.offsetBodyTop(),\n        y2: (elt.offsetBodyTop() + rect.height)\n    };\n    return zoneElt.x2 > x1 && x2 > zoneElt.x1 && zoneElt.y2 > y1 && y2 > zoneElt.y1;\n};\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/select.js","export let init = (conf, parentFunctions) => {\n    parentFunctions.setProperty('copyElts', []);\n}\n\nexport let windowEvents = {\n    onkeyup: (e, parentFunctions, conf) => {\n        if (e.which == '67' && e.ctrlKey) {\n            parentFunctions.setProperty('copyElts', parentFunctions.getSelection());\n        } else if (e.which == '86' && e.ctrlKey) {\n            conf.pasteFunction(parentFunctions.getProperty('copyElts'));\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/copyPaste.js","export let onSelectionUpdate = (params) => {\n// si l'élément HTML mka-count existe\n    if (params.selection && params.configs && !!document.getElementById(params.configs.count)) {\n        document.getElementById(params.configs.count).innerHTML = params.selection.length;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/count.js","export let init = (conf, parentFunctions) => {\n    parentFunctions.setProperty('arrows.currentFocus', null);\n    parentFunctions.setProperty('arrows.isContainerFocused', false);\n}\n\nexport let onSelectionUpdate = (params) => {\n    let selection = params.selection;\n    let parentFunctions = params.parentFunctions;\n    if (selection && parentFunctions) {\n        if (selection.length > 0) {\n            parentFunctions.setProperty('arrows.lastSelected', selection[selection.length - 1]);\n            if (selection.length === 1) {\n                parentFunctions.setProperty('arrows.currentFocus', selection[0]);\n            } else if (params.actionId !== 'arrows.shift') {\n                parentFunctions.setProperty('arrows.currentFocus', null);\n            }\n        } else {\n            parentFunctions.setProperty('arrows.lastSelected', null);\n            parentFunctions.setProperty('arrows.currentFocus', null);\n        }\n    }\n}\n\nexport let windowEvents = {\n    onmousedown: (e, parentFunctions) => {\n        parentFunctions.setProperty('arrows.isContainerFocused', parentFunctions.isMkaContainerFocused(e.target));\n        return false;\n    },\n    onkeydown: (event, parentFunctions) => {\n        let code = event.which;\n        //37=left , 38=top , 39=right , 40=bottom\n        if (code == 37 || code == 38 || code == 39 || code == 40) {\n            let lastSelected = parentFunctions.getProperty('arrows.lastSelected');\n\n            if (!lastSelected) {\n                if (parentFunctions.getProperty('arrows.isContainerFocused')) {\n                    let firstElement = parentFunctions.getSelectablesElements()[0];\n                    if (firstElement) {\n                        parentFunctions.updateSelection([firstElement]);\n                    }\n                }\n            } else {\n                event.preventDefault();\n                let centerScroll = (elt) => {\n                    let scrollX = (elt.offsetBodyLeft() + elt.offsetWidth / 2) - (window.scrollX + window.innerWidth / 2);\n                    let scrollY = (elt.offsetBodyTop() + elt.offsetHeight / 2) - (window.scrollY + window.innerHeight / 2);\n                    window.scrollBy(scrollX, scrollY);\n                }\n                centerScroll(lastSelected);\n\n                let nextElement = calculateNextElement(lastSelected, code, parentFunctions);\n\n                if (!!nextElement) {\n                    let newSelection = [];\n\n                    if (event.shiftKey && parentFunctions.getProperty('arrows.currentFocus')) {\n                        newSelection = parentFunctions.getSelection();\n                        let index = newSelection.indexOf(nextElement);\n                        if (code == 37 || code == 39) {\n                            if (index === -1) {\n                                newSelection.push(nextElement);\n                            } else {\n                                newSelection.splice(newSelection.length - 1, 1);\n                            }\n                        } else {\n                            let newElements = [];\n                            let searchNextElement = lastSelected;\n                            while (searchNextElement && searchNextElement !== nextElement) {\n                                searchNextElement = calculateNextElement(searchNextElement, (code == 38) ? 37 : 39, parentFunctions);\n                                if (searchNextElement) {\n                                    newElements.push(searchNextElement);\n                                }\n                            }\n                            if (index === -1) {\n                                newSelection = newSelection.concat(newElements);\n                            } else {\n                                newSelection.splice(index + 1);\n                            }\n\n                        }\n                        parentFunctions.updateSelection(newSelection, 'arrows.shift');\n                    } else {\n                        newSelection = [nextElement];\n                        parentFunctions.updateSelection(newSelection);\n                    }\n\n                    centerScroll(nextElement);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\nlet calculateNextElement = (fromElement, code, parentFunctions) => {\n    let interval = 10;\n    let rect = fromElement.getBoundingClientRect();\n    let posX = 0;\n    let posY = 0;\n    let updateX = 0;\n    let updateY = 0;\n    // let updateLine = 0;\n\n    switch (code) {\n        //left\n        case 37 :\n            posX = fromElement.offsetBodyLeft();\n            posY = fromElement.offsetBodyTop() + rect.height / 2;\n            updateX = -interval;\n            break;\n        //up\n        case 38 :\n            posX = fromElement.offsetBodyLeft() + rect.width / 2;\n            posY = fromElement.offsetBodyTop();\n            updateY = -interval;\n            break;\n        //right\n        case 39 :\n            posX = fromElement.offsetBodyLeft() + rect.width;\n            posY = fromElement.offsetBodyTop() + rect.height / 2;\n            updateX = interval;\n            break;\n        //down\n        case 40 :\n            posX = fromElement.offsetBodyLeft() + rect.width / 2;\n            posY = fromElement.offsetBodyTop() + rect.height;\n            updateY = interval;\n            break;\n    }\n\n    posX = posX + updateX;\n    posY = posY + updateY - window.scrollY;\n    let lineChanged = false;\n    let container = parentFunctions.getContainer();\n\n    let isSameLineThanOrigin = (elt) => {\n        let eltCenterY = elt.offsetBodyTop() + elt.getBoundingClientRect().height / 2;\n        if (code === 37) {\n            return eltCenterY >= fromElement.offsetBodyTop();\n        } else if (code === 39) {\n            return eltCenterY <= fromElement.offsetBodyTop() + rect.height;\n        }\n    }\n\n\n    let getNextElement = (isNewLine) => {\n        lineChanged = lineChanged || isNewLine;\n        let target = document.elementFromPoint(posX, posY);\n        let selectableElement = parentFunctions.getSelectableElement(target);\n        if (!selectableElement || lineChanged && isSameLineThanOrigin(selectableElement)) {\n            if (parentFunctions.isMkaContainerFocused(target)) {\n                posX = posX + updateX;\n                posY = posY + updateY;\n                return getNextElement();\n            } else {\n                if (code === 38 || code === 40 || isNewLine) {\n                    return null;\n                } else {\n                    if (code === 37) {\n                        posY = (!lineChanged) ? fromElement.offsetBodyTop() - interval - window.scrollY : posY - interval;\n                        posX = container.offsetBodyLeft() + container.getBoundingClientRect().width - interval;\n                    } else {\n                        posY = (!lineChanged) ? fromElement.offsetBodyTop() + rect.height + interval - window.scrollY : posY + interval;\n                        posX = container.offsetBodyLeft() + interval;\n                    }\n                    return getNextElement(true);\n                }\n            }\n        }\n        return selectableElement;\n    }\n    let nextElement = getNextElement();\n    return nextElement;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/arrows.js","export let windowEvents = {\n    onkeyup: (e, parentFunctions, conf) => {\n\n        let selection = parentFunctions.getSelection();\n\n        if(e.which == '46' && selection.length > 0 && typeof conf.deleteShortcut === 'function') {\n            conf.deleteShortcut(selection);\n            return true;\n        }\n\n        return false;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/deleteShortcut.js","export let init = (conf, parentFunctions) => {\n    parentFunctions.setProperty('isMkaContainerFocused', false);\n}\n\nexport let windowEvents = {\n    onkeydown: (e, parentFunctions) => {\n        if (e.ctrlKey) {\n            let code = e.which;\n\n            if ((code === 65 || code === 97) && parentFunctions.getProperty('isMkaContainerFocused')) {\n                let newSelection = parentFunctions.getSelectablesElements();\n\n                parentFunctions.updateSelection(newSelection);\n\n                e.preventDefault();\n                return true;\n            }\n        }\n        return false;\n    },\n    onmousedown: (e, parentFunctions) => {\n        parentFunctions.setProperty('isMkaContainerFocused', parentFunctions.isMkaContainerFocused(e.target));\n        return false;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/js/selectAllShortcut.js"],"sourceRoot":""}